/*
 * program4.ypp
 * Finley McIlwaine
 * Nov. 10, 2019
 * COSC4785, Program 4
 *
 * Bison grammar input file
*/
%{
#include <iostream>
#include "Error.hpp"
#include "Node.hpp"
#include "MyScanner.hpp"

using std::cout;
using std::endl;
using std::cerr;

extern Node *tree;
extern MyScanner scanner;
Error* err=new Error();

#define yylex() scanner.yylex()
#define YYERROR_VERBOSE 1

void yyerror(const char *);
%}

%locations

  /*
   * El Union
   */
%union {
  Node *pnode;
}

/*
 * token stuff
 */
%type<pnode> name
%type<pnode> program
%type<pnode> simpletype
%type<pnode> type
%type<pnode> arglist
%type<pnode> newexp
%type<pnode> exp
%type<pnode> multibrackets
%type<pnode> bracketexp
%type<pnode> bracketexps

%token<pnode> READ
%token<pnode> NULLT
%token<pnode> DOT
%token<pnode> THIS
%token<pnode> INT
%token<pnode> NEW
%token<pnode> COMMA
%token<pnode> NUMBER
%token<pnode> ID
%token<pnode> LBRACK
%token<pnode> RBRACK
%token<pnode> LPAREN
%token<pnode> RPAREN
%token<pnode> PLUS
%token<pnode> MINUS
%token<pnode> OR
%token<pnode> TIMES
%token<pnode> DIV
%token<pnode> MOD
%token<pnode> AND
%token<pnode> EQ
%token<pnode> NE
%token<pnode> GE
%token<pnode> LE
%token<pnode> GT
%token<pnode> LT
%token<pnode> NOT

%left PLUS MINUS OR
%left TIMES DIV MOD AND
%left EQ NE GE LE GT LT

%precedence RELATIONOP
%precedence SUMOP
%precedence PRODUCTOP
%precedence UNARYOP

/*
 * The Grammar :o
 */
%%
input: program {
  tree=new Node($1);
}

;

program: exp {
  $$=new ProgramNode($1);
  $$->setVal("<Exp>");
}

; /* do not ever even think about forgetting this stupid thing */ 

type: simpletype {
  $$=new TypeNode($1);
  $$->setVal("<SimpleType>");
}
| type LBRACK RBRACK {
  $$=new TypeNode($1);
  $$->setVal("<Type> lbrack rbrack");
}

;

simpletype: INT {
  $$=new SimpleTypeNode();
  $$->setVal("int");
}
| ID {
  $$=new SimpleTypeNode($1);
  $$->setVal("identifier");
}

;

name: THIS {
  $$=new NameNode();
  $$->setVal("this");
}
| ID {
  $$=new NameNode($1);
  $$->setVal("identifier");
}
| name DOT ID {
  $$=new NameNode($1,$3);
  $$->setVal("<Name> dot identifier");
}
| name bracketexp {
  $$=new NameNode($1,$2);
  $$->setVal("<Name> <BracketExp>");
}

;

arglist: exp {
  $$=new ArgListNode($1);
  $$->setVal("<Exp>");
}
| arglist COMMA exp {
  $$=new ArgListNode($1,$3);
  $$->setVal("<ArgList> <Exp>");
}
| %empty {
  $$=new ArgListNode();
  $$->setVal("empty"); /* HOW TO SHOW THIS??? */
}

;

exp: name {
  $$=new ExpNode($1);
  $$->setVal("<Name>");
}
| NUMBER {
  $$=new ExpNode($1);
  $$->setVal("number");
}
| NULLT {
  $$=new ExpNode();
  $$->setVal("null");
}
| name LPAREN arglist RPAREN {
  $$=new ExpNode($1,$3);
  $$->setVal("<Name> lparen <ArgList> rparen");
}
| READ LPAREN RPAREN {
  $$=new ExpNode();
  $$->setVal("read lparen rparen");
}
| newexp {
  $$=new ExpNode($1);
  $$->setVal("<NewExp>");
}
| PLUS exp %prec UNARYOP {
  $$=new ExpNode($2);
  $$->setVal("plus <Exp>");
}
| MINUS exp %prec UNARYOP {
  $$=new ExpNode($2);
  $$->setVal("minus <Exp>");
}
| NOT exp %prec UNARYOP {
  $$=new ExpNode($2);
  $$->setVal("not <Exp>");
}
| exp EQ exp %prec RELATIONOP {
  $$=new ExpNode($1,$3);
  $$->setVal("<Exp> eq <Exp>");
}
| exp NE exp %prec RELATIONOP {
  $$=new ExpNode($1,$3);
  $$->setVal("<Exp> ne <Exp>");
}
| exp LE exp %prec RELATIONOP {
  $$=new ExpNode($1,$3);
  $$->setVal("<Exp> le <Exp>");
}
| exp GE exp %prec RELATIONOP {
  $$=new ExpNode($1,$3);
  $$->setVal("<Exp> ge <Exp>");
}
| exp LT exp %prec RELATIONOP {
  $$=new ExpNode($1,$3);
  $$->setVal("<Exp> lt <Exp>");
}
| exp GT exp %prec RELATIONOP {
  $$=new ExpNode($1,$3);
  $$->setVal("<Exp> gt <Exp>");
}
| exp PLUS exp %prec SUMOP {
  $$=new ExpNode($1,$3);
  $$->setVal("<Exp> plus <Exp>");
}
| exp MINUS exp %prec SUMOP {
  $$=new ExpNode($1,$3);
  $$->setVal("<Exp> minus <Exp>");
}
| exp OR exp %prec SUMOP {
  $$=new ExpNode($1,$3);
  $$->setVal("<Exp> or <Exp>");
}
| exp TIMES exp %prec PRODUCTOP {
  $$=new ExpNode($1,$3);
  $$->setVal("<Exp> times <Exp>");
}
| exp DIV exp %prec PRODUCTOP {
  $$=new ExpNode($1,$3);
  $$->setVal("<Exp> div <Exp>");
}
| exp MOD exp %prec PRODUCTOP {
  $$=new ExpNode($1,$3);
  $$->setVal("<Exp> mod <Exp>");
}
| exp AND exp %prec PRODUCTOP {
  $$=new ExpNode($1,$3);
  $$->setVal("<Exp> and <Exp>");
}
| LPAREN exp RPAREN {
  $$=new ExpNode($2);
  $$->setVal("lparen <Exp> rparen");
}

;

newexp: NEW ID LPAREN arglist RPAREN {
  $$=new NewExpNode($2,$4);
  $$->setVal("new identifier lparen <ArgList> rparen");
}
| NEW simpletype bracketexps multibrackets {
  $$=new NewExpNode($2,$3,$4);
  $$->setVal("new <SimpleType> <BracketExps> <MultiBrackets>");
}
| NEW simpletype bracketexps {
  $$=new NewExpNode($2,$3);
  $$->setVal("new <SimpleType> <BracketExps>");
}
| NEW simpletype {
  $$=new NewExpNode($2);
  $$->setVal("new <SimpleType>");
}

;

bracketexps: bracketexp {
  $$=new BracketExpsNode($1);
  $$->setVal("<BracketExp>");
}
| bracketexps bracketexp {
  $$=new BracketExpsNode($1,$2);
  $$->setVal("<BracketExps> <BracketExp>");
}

;

bracketexp: LBRACK exp RBRACK {
  $$=new BracketExpNode($2);
  $$->setVal("lbrack <Exp> rbrack");
}

;

multibrackets: LBRACK RBRACK {
  $$=new MultibracketNode();
  $$->setVal("lbrack rbrack");
}
| multibrackets LBRACK RBRACK {
  $$=new MultibracketNode($1);
  $$->setVal("<Multibrackets> lbrack rbrack");
}

;


%%
void yyerror(char const *s) 
{
  // Shut up Bison let me do the talking (please and thank you)
  err->withDesc(s);
} 
