/*
 * program4.ypp
 * Finley McIlwaine
 * Nov. 10, 2019
 * COSC4785, Program 4
 *
 * Bison grammar input file
*/
%{
#include <iostream>
#include "Error.hpp"
#include "Node.hpp"
#include "MyScanner.hpp"

using std::cout;
using std::endl;
using std::cerr;

extern Node *tree;
extern MyScanner scanner;
Error* err=new Error();

#define yylex() scanner.yylex()
#define YYERROR_VERBOSE 1

void yyerror(const char *);
%}

%locations

  /*
   * El Union
   */
%union {
  Node *pnode;
}

/*
 * token stuff
 */
%type<pnode> program
%type<pnode> simpletype
%type<pnode> type
%type<pnode> arglist
%type<pnode> newexp
%type<pnode> exp
%type<pnode> multibrackets
%type<pnode> bracketexp
%type<pnode> bracketexps
%type<pnode> unaryop
%type<pnode> relationop
%type<pnode> sumop
%type<pnode> productop

%token<pnode> INT
%token<pnode> NEW
%token<pnode> COMMA
%token<pnode> NUMBER
%token<pnode> ID
%token<pnode> LBRACK
%token<pnode> RBRACK
%token<pnode> LPAREN
%token<pnode> RPAREN
%token<pnode> PLUS
%token<pnode> MINUS
%token<pnode> OR
%token<pnode> TIMES
%token<pnode> DIV
%token<pnode> MOD
%token<pnode> AND
%token<pnode> EQ
%token<pnode> NE
%token<pnode> GE
%token<pnode> LE
%token<pnode> GT
%token<pnode> LT
%token<pnode> NOT
/*
%left PLUS MINUS OR
%left TIMES DIV MOD AND
%left EQ NE GE LE GT LT

%precedence UNARYOP
%precedence PRODUCTOP
%precedence SUMOP
%precedence RELATIONOP
*/
/*
 * The Grammar :o
 */
%%
input: program {
  tree=new Node($1);
}

;

program: productop sumop relationop unaryop {
  $$=new ProgramNode($1);
  $$->setVal("<ProductOp>");
}
| newexp {
  $$=new ProgramNode($1);
  $$->setVal("<NewExp>");
}

; /* do not ever even think about forgetting this stupid thing */ 

type: simpletype {
  $$=new TypeNode($1);
  $$->setVal("<SimpleType>");
}
| type LBRACK RBRACK {
  $$=new TypeNode($1);
  $$->setVal("<Type> lbrack rbrack");
}

;

simpletype: INT {
  $$=new SimpleTypeNode();
  $$->setVal("int");
}
| ID {
  $$=new SimpleTypeNode($1);
  $$->setVal("identifier");
}

;

arglist: exp {
  $$=new ArgListNode($1);
  $$->setVal("<Exp>");
}
| arglist COMMA exp {
  $$=new ArgListNode($1,$3);
  $$->setVal("<ArgList> <Exp>");
}
| %empty {
  $$=new ArgListNode();
  $$->setVal("empty"); /* HOW TO SHOW THIS??? */
}

;

exp: NUMBER {
  $$=new ExpNode($1);
  $$->setVal("number");
}

;

newexp: NEW ID LPAREN arglist RPAREN {
  $$=new NewExpNode($2,$4);
  $$->setVal("new identifier lparen <ArgList> rparen");
}
| NEW simpletype bracketexps multibrackets {
  $$=new NewExpNode($2,$3,$4);
  $$->setVal("new <SimpleType> <BracketExps> <MultiBrackets>");
}
| NEW simpletype bracketexps {
  $$=new NewExpNode($2,$3);
  $$->setVal("new <SimpleType> <BracketExps>");
}
| NEW simpletype {
  $$=new NewExpNode($2);
  $$->setVal("new <SimpleType>");
}

;

bracketexps: bracketexp {
  $$=new BracketExpsNode($1);
  $$->setVal("<BracketExp>");
}
| bracketexps bracketexp {
  $$=new BracketExpsNode($1,$2);
  $$->setVal("<BracketExps> <BracketExp>");
}

;

bracketexp: LBRACK exp RBRACK {
  $$=new BracketExpNode($2);
  $$->setVal("lbrack <Exp> rbrack");
}

;

multibrackets: LBRACK RBRACK {
  $$=new MultibracketNode();
  $$->setVal("lbrack rbrack");
}
| multibrackets LBRACK RBRACK {
  $$=new MultibracketNode($1);
  $$->setVal("<Multibrackets> lbrack rbrack");
}

;

unaryop: PLUS {
  $$=new UnaryOpNode();
  $$->setVal("plus");
}
| MINUS {
  $$=new UnaryOpNode();
  $$->setVal("minus");
}
| NOT {
  $$=new UnaryOpNode();
  $$->setVal("not");
}


relationop: EQ {
  $$=new RelationOpNode();
  $$->setVal("eq");
}
| NE {
  $$=new RelationOpNode();
  $$->setVal("ne");
}
| LE {
  $$=new RelationOpNode();
  $$->setVal("le");
}
| GE {
  $$=new RelationOpNode();
  $$->setVal("ge");
}
| LT {
  $$=new RelationOpNode();
  $$->setVal("lt");
}
| GT {
  $$=new RelationOpNode();
  $$->setVal("gt");
}

;

sumop: PLUS {
  $$=new SumOpNode();
  $$->setVal("plus");
}
| MINUS {
  $$=new SumOpNode();
  $$->setVal("minus");
}
| OR {
  $$=new SumOpNode();
  $$->setVal("or");
}

;

productop: TIMES {
  $$=new ProductOpNode();
  $$->setVal("times");
}
| DIV {
  $$=new ProductOpNode();
  $$->setVal("div");
}
| MOD {
  $$=new ProductOpNode();
  $$->setVal("mod");
}
| AND {
  $$=new ProductOpNode();
  $$->setVal("and");
}

;

%%
void yyerror(char const *s) 
{
  // Shut up Bison let me do the talking (please and thank you)
  err->withDesc(s);
} 
